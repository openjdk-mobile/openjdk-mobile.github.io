{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Java on Mobile","text":"<p>Bringing real Java to mobile.</p> <p>Java runs everywhere \u2014 server, cloud, and desktop \u2014 but running it seamlessly on mobile remains challenging. This project aims to fix that by creating the code, tools, and documentation to make Java a first-class citizen on iOS and Android.</p> <p>A key part of this effort is the OpenJDK/mobile project \u2014 an official downstream repository of OpenJDK/jdk containing the minimal patches required for JVM and library support on mobile devices. Our long-term goal is to upstream these patches into OpenJDK/jdk, eliminating the need for a separate repository.</p> <p>We focus on two main use cases:</p> <ul> <li>Java libraries on mobile \u2013 Allow developers to take existing Java libraries and convert them into fully supported components on mobile platforms.</li> <li>Java applications on mobile \u2013 Enable developers to write full mobile applications in Java, including JavaFX-based apps.</li> </ul> <p>\u26a0\ufe0f Note: This is not (yet) a tutorial for building mobile apps in Java. The goal is rather to build the infrastructure that makes it possible. We try to document all required steps in detail, and we hope that more contributors will join this project.</p> <p>From here, you can explore:</p> <ul> <li>Mission \u2013 Our philosophy, constraints, and guiding principles.</li> <li>Platforms \u2013 How we plan to bring Java to iOS and Android.</li> <li>Roadmap \u2013 Next steps and current issues.</li> <li>OpenJDK Mobile \u2013 Relationship with the official OpenJDK/mobile project.</li> </ul>"},{"location":"android/","title":"Android Support","text":"<p>Work for Android is still TODO.</p>"},{"location":"android/#goals","title":"Goals","text":"<ul> <li>Provide consistent JDK builds for Android.</li> <li>Simplify integration with Gradle/Android Studio.</li> <li>Align tooling with iOS where possible.</li> </ul>"},{"location":"android/#next-steps","title":"Next Steps","text":"<ul> <li>Define build process.</li> <li>Identify differences from iOS approach.</li> <li>Establish CI for Android artifacts.</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>This project is organized around a modular architecture that separates the concerns of the Java runtime, the Java standard library, application code, and supporting tooling. The main components are:</p>"},{"location":"architecture/#1-vm","title":"1. VM","text":"<p>The Virtual Machine (VM) is built from OpenJDK/mobile. It provides the core runtime functionality of OpenJDK on mobile platforms and is implemented natively on each target OS.  </p> <ul> <li>Delivered as a shared or static library.  </li> <li>Contains the standard OpenJDK VM features adapted for mobile environments.  </li> <li>Ensures compatibility between server/cloud/desktop Java and mobile Java.  </li> </ul>"},{"location":"architecture/#2-jdk-classes","title":"2. JDK Classes","text":"<p>The JDK classes component is also built from OpenJDK/mobile and contains the standard Java libraries for mobile:  </p> <ul> <li>Includes class files in bytecode form (jars, jmods, or optionally AOT-compiled classes).  </li> <li>Includes native code required by these class files.  </li> <li>Ensures that mobile developers can use standard Java APIs without writing platform-specific code.  </li> </ul>"},{"location":"architecture/#3-application-code-and-dependencies","title":"3. Application Code and Dependencies","text":"<p>Application-specific code represents the project or app being developed:  </p> <ul> <li>Can contain Java and native code.  </li> <li>May depend on external libraries or frameworks.  </li> <li>Is project-specific and built separately from the VM and JDK classes.  </li> </ul>"},{"location":"architecture/#4-tooling","title":"4. Tooling","text":"<p>The tooling component ties everything together:  </p> <ul> <li>Bundles the VM, JDK classes, and application code efficiently.  </li> <li>Produces outputs ready for mobile deployment (e.g., Play Store, App Store) or development integration (e.g., Xcode, Android Studio).  </li> <li>Configurable to allow different use cases, from full apps to reusable Java libraries for mobile.  </li> </ul> <p>This architecture ensures a clear separation of concerns, maintains alignment with upstream OpenJDK, and enables developers to work with standard Java on mobile platforms without compromise.</p>"},{"location":"contributing/","title":"Contributing to the Java on Mobile Organization","text":"<p>Welcome! This organization hosts multiple projects aimed at bringing real OpenJDK Java to mobile platforms. Our goal is to provide code, tools, and documentation that allow developers to build libraries and applications for mobile devices using standard Java.</p>"},{"location":"contributing/#projects-in-this-organization","title":"Projects in This Organization","text":"<p>Some of the current and planned projects include:  </p> <ul> <li>OpenJDK/mobile \u2013 downstream OpenJDK repository with minimal patches for iOS/Android.  </li> <li>Build and CI tools \u2013 GitHub Actions for continuous builds of mobile JDKs.  </li> <li>AOT / performance experiments \u2013 strategies to improve runtime performance on mobile.  </li> <li>JavaFX on mobile \u2013 integration of OpenJFX with the OpenJDK build system.  </li> </ul> <p>Each project may have its own repository, README, and issue tracker. Contributions should target the specific project most relevant to your work.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Identify the project you want to contribute to. Check the project README for contribution guidelines.  </li> <li>Fork the repository and create a feature branch.  </li> <li>Implement your changes, following the coding conventions of that project.  </li> <li>Submit a pull request, explaining:  </li> <li>What the change does  </li> <li>How it aligns with the project mission and core architecture  </li> <li>Any dependencies or interactions with other sub-projects  </li> </ol>"},{"location":"contributing/#alignment-with-the-mission","title":"Alignment with the Mission","text":"<p>All contributions should support the mission and core architecture:</p> <ul> <li>Ensure the change advances real OpenJDK Java on mobile platforms.  </li> <li>Avoid mobile-specific workarounds unless necessary.  </li> <li>Respect existing design patterns and build system conventions.  </li> <li>Aim for maintainability and potential upstreaming to OpenJDK.  </li> </ul> <p>This applies across all sub-projects. Contributions that diverge may require additional review.</p>"},{"location":"contributing/#licensing-ownership","title":"Licensing &amp; Ownership","text":"<ul> <li>All code in the organization is open-source under Apache 2.0.  </li> <li>By contributing, you agree your contribution is licensed under Apache 2.0 and that Gluon retains copyright ownership.  </li> <li>Please sign the Contributor License Agreement (CLA) before contributing.</li> </ul>"},{"location":"contributing/#reporting-issues-discussion","title":"Reporting Issues &amp; Discussion","text":"<ul> <li>Bug reports or feature requests: Open an issue in the relevant repository.  </li> <li>Documentation or tooling suggestions: Open a pull request in the relevant repository.  </li> <li>General discussions: Use issues labeled <code>discussion</code> or contact maintainers directly.  </li> </ul> <p>Thank you for helping make Java a first-class language for mobile development!</p>"},{"location":"ios/","title":"iOS Support","text":"<p>Bringing Java to iOS follows a staged approach. First we validate the runtime with a minimal example, then we provide two independent tracks for developers: generating Java libraries for use in iOS projects, or building full JavaFX applications.</p> <p>This is shown in the following image.</p> <pre><code>flowchart TD\nstyle JVM fill:#4287f5\nstyle classes fill:#4287f5\nstyle OpenJDK fill:#4287f5\nstyle helloworld fill:#05ab3d\nstyle javalib fill:#05ab3d\nstyle javaapp fill:#05ab3d\n\nJVM --&gt; OpenJDK[OpenJDK Mobile SDK]\nclasses[JDK Classes] --&gt; OpenJDK\nOpenJDK --&gt; helloworld[HelloWorld.jar\non iOS]\nhelloworld --&gt; javalib[Native java libs\nin iOS apps]\nhelloworld --&gt; javaapp[JavaFX apps]</code></pre>"},{"location":"ios/#tracks","title":"Tracks","text":"<ul> <li>HelloWorld on iOS \u2013 Validate the VM and class libraries with a minimal program.</li> <li>Java Libraries for iOS \u2013 Expose Java methods to be callable from Objective-C/Swift.</li> <li>JavaFX Applications on iOS \u2013 Build full JavaFX apps for iOS.</li> </ul>"},{"location":"issues/","title":"Issues &amp; Challenges","text":"<p>Challenges are grouped by use case.</p>"},{"location":"issues/#java-app-on-ios","title":"Java App on iOS","text":"<ul> <li>Improve application footprint.</li> <li>Improve runtime memory usage.</li> <li>Use AOT methods if available.</li> </ul>"},{"location":"issues/#javafx-app-on-ios","title":"JavaFX App on iOS","text":"<ul> <li>Compile OpenJFX for iOS.</li> <li>Ensure compatibility with native UI systems.</li> </ul>"},{"location":"issues/#java-library-on-ios","title":"Java Library on iOS","text":"<ul> <li>Expose public Java APIs for use by Swift/Objective-C developers.</li> </ul>"},{"location":"mission/","title":"Mission &amp; Philosophy","text":""},{"location":"mission/#our-goal","title":"Our Goal","text":"<p>We want to re-establish Java as a top-quality, cross-platform language for mobile. This means providing the real Java \u2014 fully aligned with OpenJDK \u2014 along with the tools and documentation needed to run it on iOS and Android.</p>"},{"location":"mission/#core-principles","title":"Core Principles","text":"<ul> <li>Real Java Only \u2013 We stay as close as possible to OpenJDK. Mobile developers should be able to use all features available in the upstream JDK without hacks or workarounds.</li> <li>Developer-first Alignment \u2013 If something exists in OpenJDK, mobile developers should have access to it. There should be no \u201cmobile-only\u201d divergence in functionality.</li> <li>Infrastructure Focus \u2013 The project creates the tools, code, and documentation needed to bring Java to mobile. We are not writing tutorials for building apps \u2014 the community can build on this foundation.</li> <li>Two Primary Use Cases:</li> <li>Libraries: Enable Java libraries to be compiled and packaged as first-class components on mobile platforms.</li> <li>Applications: Enable full Java apps (including JavaFX) to run on mobile platforms with minimal platform-specific code.</li> </ul>"},{"location":"mission/#vision","title":"Vision","text":"<p>By adhering to these principles, we aim to create a sustainable ecosystem where:</p> <ul> <li>Java developers can confidently build for mobile using the standard JDK.</li> <li>Mobile platforms gain robust, maintainable Java support.</li> <li>Contributions are guided by clear philosophy rather than ad hoc decisions.</li> </ul>"},{"location":"mission/#improving-step-by-step","title":"Improving step by step","text":"<p>It is often tempting to create a nice, impressive, visually attractive demo to showcase the potential of a project. Especially with JavaFX on iOS, a demo of a polished JavaFX application running on an iPhone can convince many developers and non-developers alike that there are exciting possibilities.</p> <p>While that is certainly true, there is a huge difference between a demo created by a single team with many years of experience\u2014who know the ins and outs of the components\u2014and a mature, stable, well-documented project that enables any Java developer to build a compelling Java application on iOS.</p> <p>In this project, we move forward in small, documented, and maintainable steps. From past experience, we have learned that maintainability is a key factor for success. Especially with fast-moving components, the challenge is not merely to create something that works today, but to ensure it continues to work in the future, as most components inevitably evolve (e.g., a new version of iOS/Android, a new JVM, a new AOT compiler, or new external deployment tools).</p> <p>While this approach may look less flashy, we are convinced that the strong, documented, and maintainable foundations we are building will lead to better results and greater developer appreciation in the long run.</p>"},{"location":"mission/#managing-complexity","title":"Managing Complexity","text":"<p>The OpenJDK project itself is complex, and a mobile operating system with its ecosystem and specific requirements is complex as well. When complex components need to work together or be integrated, overall complexity increases, and maintenance costs can rise sharply. To keep the system maintainable and reliable, we aim to minimize the number of components and the number of build tools, ensuring a lean and coherent architecture.</p>"},{"location":"mission/#keeping-mobile-in-sync","title":"Keeping Mobile in Sync","text":"<p>All commits applied to OpenJDK/jdk are automatically merged into OpenJDK/mobile. This ensures that the downstream repository always contains the latest Java, avoiding discrepancies between server, cloud, desktop, and mobile development. Maintaining this alignment is a key requirement, so that mobile developers can rely on the same Java platform as other environments while we continue to evolve mobile support.</p>"},{"location":"openjdk-mobile/","title":"OpenJDK Mobile","text":"<p>The OpenJDK/mobile repository is an official downstream project of OpenJDK/jdk. It currently contains a small set of iOS- and Android-specific patches required to build a JVM and class libraries that run on mobile devices.</p>"},{"location":"openjdk-mobile/#project-goal","title":"Project Goal","text":"<p>The ultimate goal is to make OpenJDK/mobile obsolete by upstreaming mobile-specific patches into OpenJDK/jdk. This ensures:</p> <ul> <li>Mobile support is integrated directly in the standard JDK.</li> <li>No long-term maintenance is required for a separate downstream repository.</li> <li>Consistency and quality are preserved across all platforms.</li> </ul>"},{"location":"openjdk-mobile/#constraints","title":"Constraints","text":"<p>Upstreaming patches requires a very high-quality bar:</p> <ul> <li>Patches must not introduce regressions on other platforms.</li> <li>Patches must not increase maintenance burden for OpenJDK developers.</li> <li>Only patches with clear benefits and no negative impact will be proposed for upstreaming.</li> </ul> <p>While it is technically \"easier\" to apply patches in OpenJDK/mobile than in upstream OpenJDK/jdk, this does not mean that anything goes. The quality bar for OpenJDK/mobile is still high, because only well-tested and maintainable patches can eventually be upstreamed. Each patch is carefully evaluated for correctness, maintainability, and long-term sustainability.</p>"},{"location":"platforms/","title":"Platforms Overview","text":"<p>The project covers multiple mobile platforms. Work is divided per platform.</p>"},{"location":"platforms/#supported-platforms","title":"Supported Platforms","text":"<ul> <li>iOS</li> <li>Android</li> </ul> <p>Other platforms may be considered in the future.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#near-term","title":"Near-term","text":"<ul> <li>Build OpenJDK/Zero interpreter for iOS.</li> <li>Provide downloadable JDK builds.</li> <li>Define native/Java bridge approach.</li> </ul>"},{"location":"roadmap/#medium-term","title":"Medium-term","text":"<ul> <li>Create usable Xcode framework.</li> <li>Explore Project Leyden for AOT.</li> <li>Start Android builds.</li> </ul>"},{"location":"roadmap/#long-term","title":"Long-term","text":"<ul> <li>Full JavaFX integration with OpenJDK build.</li> <li>Metal backend for JavaFX on iOS.</li> <li>App packaging and distribution tooling.</li> </ul>"},{"location":"ios/helloworld/","title":"HelloWorld on iOS","text":"<p>HelloWorld is the first milestone to bring Java to iOS. It validates the runtime and ensures core components work correctly.</p>"},{"location":"ios/helloworld/#why-helloworld-first","title":"Why HelloWorld First","text":"<ul> <li>Validate VM + classlibs \u2013 confirms that the OpenJDK/mobile VM and standard class libraries work on iOS.</li> <li>Close to upstream \u2013 minimal program stays aligned with OpenJDK to surface regressions.</li> <li>Continuous regression testing \u2013 daily builds of <code>HelloWorld.jar</code> detect issues early.</li> </ul>"},{"location":"ios/helloworld/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>VM launches on simulator and device and executes <code>HelloWorld</code> output without crashes.</li> <li>Classloaders, basic reflection, and standard library calls succeed.</li> <li>Artifact is reproducible and integrated into CI for regression detection.</li> </ul>"},{"location":"ios/helloworld/#steps-to-get-it-working","title":"Steps to get it working","text":"<ul> <li>Running <code>helloworld</code> involves a number of steps described in the ios-tools repo</li> <li>For each step you can choose to build (e.g. OpenJDK/mobile) yourself or download a build from the repo's releases</li> </ul> <p>\u26a0\ufe0f Note: Running on an iOS device is working properly. Running on a simulator is still to be fixed.</p>"},{"location":"ios/javafx/","title":"JavaFX Applications on iOS","text":"<p>This track enables full JavaFX applications to run as native iOS apps.</p>"},{"location":"ios/javafx/#requirements","title":"Requirements","text":"<ul> <li>JavaFX runtime adapted for iOS \u2013 platform layer and native peers integrated with iOS.</li> <li>Platform integration \u2013 integrate JavaFX lifecycle with <code>UIApplication</code> lifecycle.</li> <li>Rendering pipeline \u2013 map JavaFX rendering to iOS graphics APIs, handle touch events.</li> <li>Packaging &amp; deployment \u2013 bundle VM, JavaFX runtime, resources, and app code into installable iOS app.</li> </ul>"},{"location":"ios/javafx/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Simple JavaFX scene renders on iOS and handles touch input.</li> <li>App lifecycle (background/foreground/rotation) works correctly.</li> <li>Packaging produces a deployable iOS app that passes basic stability and UI responsiveness tests.</li> </ul>"},{"location":"ios/javafx/#approach","title":"Approach","text":"<p>Both OpenJDK and OpenJFX have several requirements for the underlying operating system and environment, and both rely on a variety of tools (including compilers and linkers) to build artifacts. To minimize overlap and increase consistency, we aim to leverage the same tools. Therefore, we will first build the OpenJFX code using the OpenJDK build system.</p> <p>Although, in theory, we only need to build OpenJFX for iOS and Android, using the same approach for  building OpenJFX on desktop platforms offers benefits. Work of this is ongoing in the https://github.com/openjdk-mobile/openjfx-build repository</p>"},{"location":"ios/library/","title":"Java Libraries for iOS","text":"<p>This track enables Java libraries to be first-class components in iOS projects, callable from Objective-C/Swift.</p>"},{"location":"ios/library/#requirements","title":"Requirements","text":"<ul> <li>Explicit export model \u2013 annotate or map Java methods/classes to be exposed to iOS.</li> <li>Code generation \u2013 auto-generate native glue (C/Objective-C headers, shims, registration code) packaged with the native library.</li> <li>Runtime bridging \u2013 native entry points that call the JVM embedding API, handle threading, and manage lifetimes.</li> <li>Data marshaling rules \u2013 primitives, strings, arrays, objects, callbacks, exceptions.</li> <li>Packaging \u2013 produce iOS deliverables (static library / xcframework + headers or Xcode module).</li> </ul>"},{"location":"ios/library/#example","title":"Example","text":"<pre><code>// Java\npublic class HelloLib {\n    @ExportToNative(\"greet\")\n    public static String greet(String name) { return \"Hello \" + name; }\n}\n</code></pre> <p>would result in</p> <p><pre><code>// Generated native header\nconst char* HelloLib_greet(const char* name);\n</code></pre> Call from Objective-C/Swift like any native function.</p>"},{"location":"ios/library/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li> <p>Example Java library exposes several methods callable from Objective-C/Swift.</p> </li> <li> <p>Generated glue is reproducible and minimal.</p> </li> <li> <p>Unit tests cover marshaling, error mapping, and callbacks.</p> </li> </ul>"}]}